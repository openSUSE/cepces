#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# This file is part of cepces.
#
# cepces is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# cepces is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with cepces.  If not, see <http://www.gnu.org/licenses/>.
#
# pylint: disable=broad-except,invalid-name

"""
This is a submission helper for user certificates.

It requires that you have a valid kerberos ticket in your credential cache (/tmp/krb5cc_<UID>).
This is normally automatically created during login with a domain account by SSSD.
You can manually aquire a kerberos ticket via `kinit username@DOMAIN.TLD`.
Check your ticket with `klist`.
"""

import os
import sys
import traceback
import argparse
import requests
from pyasn1.codec.der.encoder import encode
from pyasn1.type import char
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cepces.certmonger.core import Result
from cepces.certmonger.operation import Operation
from cepces.config import Configuration
from cepces.core import Service


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def init_service(global_overrides, krb5_overrides):
    # Load the configuration and instantiate a service.
    config = Configuration.load(global_overrides=global_overrides,
                                krb5_overrides=krb5_overrides)
    if config.openssl_seclevel and config.openssl_seclevel.isnumeric():
        requests.packages.urllib3.util.ssl_.DEFAULT_CIPHERS = 'ALL:@SECLEVEL=%s' % config.openssl_seclevel
    service = Service(config)
    return service

def list_templates(service):
    print("\n".join(service.templates))

def request(service, key_file, cert_file, profile, keysize, passphrase):
    if os.path.exists(key_file):
        with open(key_file, 'rb') as f:
            key = serialization.load_pem_private_key(
                f.read(),
                password=passphrase.encode() if passphrase else None,
                backend=default_backend()
            )
    else:
        print(str(key_file)+' does not exist, generating a new key...')
        key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=int(keysize),
        )
        enc = serialization.NoEncryption()
        if(passphrase):
            enc = serialization.BestAvailableEncryption(passphrase.encode())
        with open(key_file, 'wb') as f:
            f.write(key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=enc,
            ))

    csr = x509.CertificateSigningRequestBuilder().subject_name(x509.Name([
        x509.NameAttribute(NameOID.COMMON_NAME, profile),
    ]))
    csr = csr.add_extension(
        x509.UnrecognizedExtension(
            oid=x509.ObjectIdentifier('1.3.6.1.4.1.311.20.2'),
            value=encode(char.BMPString(profile))
        ),
        critical=False
    )
    csr = csr.sign(key, hashes.SHA256())

    #csr_text = csr.public_bytes(serialization.Encoding.PEM).decode()
    #print(csr_text)

    result = service.request(
        csr,
        renew=None,
    )

    # If we have a certificate, save it
    if result.token:
        pem = result.token.public_bytes(serialization.Encoding.PEM)

        with open(cert_file, 'w') as f:
            f.write(pem.decode().strip())
            print('Certificate written to:', cert_file)
        sys.exit(0)

    # Output a "cookie" that can be used to later poll the status.
    print('Certificate approval pending. Poll later with the following info.')
    print('Request ID:', result.request_id)
    print('Reference:', result.reference)
    sys.exit(0)

def poll(service, cert_file, request_id, reference):
    result = service.poll(int(request_id), reference)

    # If we have a certificate, save it
    if result.token:
        pem = result.token.public_bytes(serialization.Encoding.PEM)

        with open(cert_file, 'w') as f:
            f.write(pem.decode().strip())
            print('Certificate written to:', cert_file)
        sys.exit(0)

    # Output a "cookie" that can be used to later poll the status.
    print('Certificate approval still pending. Poll later with the following info.')
    print('Request ID:', result.request_id)
    print('Reference:', result.reference)
    sys.exit(0)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='cepces submission helper for user certs')
    parser.add_argument('action',
        choices=['list-templates', 'request', 'poll'])
    parser.add_argument('--server',
        help='Hostname of the issuing certification authority')
    parser.add_argument('--auth',
        help='Authentication mechanism used for connecting to the service',
        choices=['Anonymous', 'Kerberos',
                 'UsernamePassword', 'Certificate'],
        default='Kerberos')
    parser.add_argument('--keytab', help='Use the specified keytab')
    parser.add_argument('--principals',
        help='A list of principals to try when requesting a ticket')
    parser.add_argument('--openssl-seclevel', help='The openssl security level')
    parser.add_argument('--profile', '-T', help='The template name for the request')
    parser.add_argument('--keyfile', '-k', help='The private key file for the signing request, will be generated/created if does not exist')
    parser.add_argument('--certfile', '-f', help='The certificate file to write on successful request')
    parser.add_argument('--keysize', '-s', help='The key size of the key to generate', default='4096')
    parser.add_argument('--passphrase', '-p', help='The passphrase to decrypt the existing key file or to encrypt the generated key')
    parser.add_argument('--request-id', '-i', help='The request ID to poll for')
    parser.add_argument('--reference', '-r', help='The request refrence to poll for')
    args = parser.parse_args()

    g_overrides = {}
    if args.server is not None:
        g_overrides['server'] = args.server
        g_overrides['auth'] = args.auth
        endpoint = 'https://%s/ADPolicyProvider_CEP_%s/service.svc/CEP' % \
                        (args.server, args.auth)
        g_overrides['endpoint'] = endpoint
    if args.openssl_seclevel is not None:
        g_overrides['openssl_seclevel'] = args.openssl_seclevel

    k_overrides = {
        # this script is intended to use as normal user with
        # existing ccache created during login, e.g. /tmp/krb5cc_1000
        # so we disable the ccache creation feature and
        # pass empty principals to use the default one
        'ccache': 'False',
        'principals': '',
    }
    if args.keytab is not None:
        k_overrides['keytab'] = args.keytab
    if args.principals is not None:
        k_overrides['principals'] = args.principals

    try:
        service = init_service(g_overrides, k_overrides)
        if args.action == 'list-templates':
            list_templates(service)
        elif args.action == 'request':
            if args.keyfile == None or args.certfile == None or args.profile == None:
                raise Exception('--keyfile, --certfile, --profile is required')
            request(service, args.keyfile, args.certfile, args.profile, args.keysize, args.passphrase)
        elif args.action == 'poll':
            if args.certfile == None or args.request_id == None or args.reference == None:
                raise Exception('--certfile, --request-id, --reference is required')
            poll(service, args.certfile, args.request_id, args.reference)
    except Exception:
        eprint(traceback.format_exc())
        sys.exit(1)
